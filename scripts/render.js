#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { marked } from 'marked';
import crypto from 'node:crypto';

const DIST_DIR = 'dist';
const TEMPLATES_DIR = 'templates';
const DATA_DIR = path.join(DIST_DIR, 'data');

function ensureDirectories() { [DIST_DIR, DATA_DIR, path.join(DIST_DIR,'articles'), path.join(DIST_DIR,'posts')].forEach(dir => { if(!fs.existsSync(dir)) fs.mkdirSync(dir,{recursive:true}); }); }
function loadTemplate(templateName){ const templatePath=path.join(TEMPLATES_DIR, `${templateName}.html`); if(fs.existsSync(templatePath)) return fs.readFileSync(templatePath,'utf8'); const fallbackPath=path.join(TEMPLATES_DIR,'article-template.html'); if(fs.existsSync(fallbackPath)) return fs.readFileSync(fallbackPath,'utf8'); throw new Error(`Template not found: ${templateName}`); }
function materializeAssets(assets){ if(!assets) return; const assetsDir=path.join(DIST_DIR,'assets'); if(!fs.existsSync(assetsDir)) fs.mkdirSync(assetsDir,{recursive:true}); assets.forEach(a=>{ if(!a||typeof a!=='object'||!a.url||!a.url.startsWith('data:')) return; const match=a.url.match(/^data:([^;]+);base64,(.+)$/); if(!match) return; const mime=match[1]; const b64=match[2]; let ext='bin'; if(mime==='image/png') ext='png'; else if(mime==='image/jpeg') ext='jpg'; else if(mime==='image/gif') ext='gif'; else if(mime==='image/webp') ext='webp'; const safeName=(a.name || ('asset-'+crypto.randomBytes(4).toString('hex'))).replace(/[^A-Za-z0-9_.-]/g,'_').replace(/\.+$/,''); const fileName=safeName+'.'+ext; const filePath=path.join(assetsDir,fileName); try { fs.writeFileSync(filePath, Buffer.from(b64,'base64')); a.url='/assets/'+fileName; } catch(e) { console.warn('Failed to write asset', fileName, e.message); } }); }
function replaceAssetPlaceholders(markdown, assets){ if(!assets||assets.length===0) return markdown; return markdown.replace(/!\[(.*?)\]\(asset:([^\)]+)\)/g,(m,alt,name)=>{ const asset=assets.find(a=>a.name===name||a.name===decodeURIComponent(name)); if(!asset) return m; asset._usedInline=true; if(asset.type==='image'){ return `![${alt||asset.alt||''}](${asset.url})`; } return `[${alt||asset.name}](${asset.url})`; }); }
function renderContent(content, assets){ if(content.format==='html') return content.body; let md=content.body; md=replaceAssetPlaceholders(md, assets); return marked.parse(md); }
function buildRemainingAssetsHtml(assets){ if(!assets||assets.length===0) return { hero:'', gallery:'', attachments:''}; let hero='', galleryItems='', attachments=''; assets.forEach(a=>{ if(a._usedInline) return; switch(a.type){ case 'image': if(a.placement==='hero'){ hero+=`<div class="hero-image"><img src="${a.url}" alt="${a.alt||''}" />${a.caption?`<p class=\"caption\">${a.caption}</p>`:''}</div>\n`; } else if(a.placement==='gallery'){ galleryItems+=`<div class="gallery-item"><img src="${a.url}" alt="${a.alt||''}" />${a.caption?`<p class=\"caption\">${a.caption}</p>`:''}</div>\n`; } else if(a.placement==='attachment'){ attachments+=`<div class="attachment"><a href="${a.url}" download>${a.name}</a>${a.caption?`<p class=\"caption\">${a.caption}</p>`:''}</div>`; } break; case 'video': galleryItems+=`<div class="video-container"><video controls><source src="${a.url}" type="video/mp4"></video>${a.caption?`<p class=\"caption\">${a.caption}</p>`:''}</div>`; break; case 'document': attachments+=`<div class="document-link"><a href="${a.url}" target="_blank">${a.name}</a>${a.caption?`<p class=\"description\">${a.caption}</p>`:''}</div>`; break; case 'audio': attachments+=`<div class="audio-item"><audio controls src="${a.url}"></audio>${a.caption?`<p class=\"caption\">${a.caption}</p>`:''}</div>`; break; }}); const gallery=galleryItems?`<div class="asset-gallery">${galleryItems}</div>`:''; return { hero, gallery, attachments }; }
function updateMenuJson(metadata, contentType, filename){ const menuPath=path.join(DATA_DIR,'menu.json'); let menu=[]; try { if(fs.existsSync(menuPath)) menu=JSON.parse(fs.readFileSync(menuPath,'utf8')); } catch{} const url=`/${contentType}/${filename}`; const menuItem={ name:metadata.title, href:url, active:false }; const existingIndex=menu.findIndex(i=>i.href===url); if(existingIndex>=0) menu[existingIndex]={ ...menu[existingIndex], ...menuItem }; else menu.push(menuItem); fs.writeFileSync(menuPath, JSON.stringify(menu,null,2)); }
function updateArticlesJson(payload, contentType, filename){ const articlesPath=path.join(DATA_DIR,'articles.json'); let articles=[]; try { if(fs.existsSync(articlesPath)) articles=JSON.parse(fs.readFileSync(articlesPath,'utf8')); } catch{} const url=`/${contentType}/${filename}`; const articleData={ title:payload.metadata.title, url, description:payload.metadata.description || payload.content.excerpt || '', tags:payload.metadata.tags||[], category:payload.metadata.category||contentType, author:payload.metadata.author||'', publishDate:payload.metadata.publishDate||new Date().toISOString(), template:payload.metadata.template||'article-template' }; if(payload.seo) articleData.seo=payload.seo; const existingIndex=articles.findIndex(a=>a.url===url); if(existingIndex>=0) articles[existingIndex]={ ...articles[existingIndex], ...articleData }; else articles.push(articleData); fs.writeFileSync(articlesPath, JSON.stringify(articles,null,2)); }
function buildSearchIndex(payload, contentType, filename){ const searchPath=path.join(DATA_DIR,'search.json'); let searchIndex=[]; try { if(fs.existsSync(searchPath)) searchIndex=JSON.parse(fs.readFileSync(searchPath,'utf8')); } catch{} const url=`/${contentType}/${filename}`; const searchEntry={ title:payload.metadata.title, url, content:payload.content.body.substring(0,500), tags:payload.metadata.tags||[], category:payload.metadata.category||contentType }; const existingIndex=searchIndex.findIndex(e=>e.url===url); if(existingIndex>=0) searchIndex[existingIndex]=searchEntry; else searchIndex.push(searchEntry); fs.writeFileSync(searchPath, JSON.stringify(searchIndex,null,2)); }
function generateSEOMetaTags(payload){ const seo=payload.seo||{}; const metadata=payload.metadata; return `\n    <meta name="description" content="${seo.metaDescription || metadata.description || ''}">\n    <meta name="keywords" content="${(seo.keywords || metadata.tags || []).join(', ')}">\n    <meta name="author" content="${metadata.author || ''}">\n    <meta property="og:title" content="${metadata.title}">\n    <meta property="og:description" content="${seo.metaDescription || metadata.description || ''}">\n    <meta property="og:type" content="article">\n    ${seo.canonicalUrl ? `<link rel="canonical" href="${seo.canonicalUrl}">` : ''}\n  `.trim(); }
async function renderArticle(payload){ ensureDirectories(); const contentType=payload.type||'articles'; const filename=payload.deployment.filename; const template=loadTemplate(payload.metadata.template||'article-template'); materializeAssets(payload.assets); const contentHtml=renderContent(payload.content,payload.assets); const { hero, gallery, attachments } = buildRemainingAssetsHtml(payload.assets); const seoTags=generateSEOMetaTags(payload); let html=template.replace(/\{\{title\}\}/g,payload.metadata.title).replace(/\{\{content\}\}/g,contentHtml).replace(/\{\{assets\}\}/g, hero+gallery+attachments).replace(/\{\{seo-meta\}\}/g,seoTags).replace(/\{\{description\}\}/g,payload.metadata.description||'').replace(/\{\{author\}\}/g,payload.metadata.author||'').replace(/\{\{publishDate\}\}/g,payload.metadata.publishDate||''); if(html.includes('<!-- Write your article content here')) html=html.replace(/<!-- Write your article content here[^>]*-->/, contentHtml); const outputDir=path.join(DIST_DIR, contentType); if(!fs.existsSync(outputDir)) fs.mkdirSync(outputDir,{recursive:true}); const outputPath=path.join(outputDir, filename); fs.writeFileSync(outputPath, html); updateMenuJson(payload.metadata, contentType, filename); updateArticlesJson(payload, contentType, filename); buildSearchIndex(payload, contentType, filename); console.log(`::set-output name=title::${payload.metadata.title}`); console.log(`::set-output name=filename::${filename}`); console.log(`::set-output name=type::${contentType}`); return { outputPath, title:payload.metadata.title, filename, type:contentType }; }
if (import.meta.url === `file://${process.argv[1]}`){ const payloadFile=process.argv[2]; if(!payloadFile){ console.error('Usage: node scripts/render.js <payload-file>'); process.exit(1);} if(!fs.existsSync(payloadFile)){ console.error(`Payload file not found: ${payloadFile}`); process.exit(1);} try { const payload=JSON.parse(fs.readFileSync(payloadFile,'utf8')); if(!payload.metadata || !payload.content || !payload.deployment) throw new Error('Invalid payload structure: missing required fields (metadata, content, deployment)'); console.log('Rendering article:', payload.metadata.title); const result=await renderArticle(payload); console.log('Successfully rendered to:', result.outputPath); } catch(error){ console.error('Error rendering article:', error.message); process.exit(1);} }
export { renderArticle, updateMenuJson, updateArticlesJson };
